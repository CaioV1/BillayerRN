import RNFS from 'react-native-fs'
import { Alert, Share } from 'react-native';
import { useContext, useState } from "react";
import DocumentPicker from 'react-native-document-picker'
import { NativeStackNavigationProp } from "@react-navigation/native-stack";

import Balance from '../../../models/schemas/BalanceSchema';
import Category from '../../../models/schemas/CategorySchema';
import Transaction from '../../../models/schemas/TransactionSchema';
import RootStackParamList from "../../../models/interfaces/RootScreensParams";

import useGlobalBalance from "../../../hooks/useBalance";
import { getNextMonthDate } from '../../../utils/date.util';
import { RealmContext } from '../../../configs/RealmContext';
import { importData } from '../../../services/transaction.service';
import { AppConfigContext } from "../../../context/appConfig.context";

const { useRealm, useQuery } = RealmContext;

const useBalance = (_navigation: NativeStackNavigationProp<RootStackParamList, "Balance">) => {
  const realm = useRealm();
  const listTransactions = useQuery(Transaction);
  const { listCategory, listBalance, getAllCurrentValues } = useGlobalBalance();
  const { appConfig, clearDatabase, setAppConfig, createNewBalances } = useContext(AppConfigContext);
  
  const [loading, setLoading] = useState<boolean>(false);

  const importBalances = async () => {
    setLoading(true);
    
    try {
      const fileInfo = await DocumentPicker.pickSingle({ type: ['text/plain', 'public.text'] });
      const textFile = await RNFS.readFile(fileInfo.uri);
      const dataFromBackup: {
        balances: Array<Balance>,
        categories: Array<Category>,
        transactions: Array<Transaction>
      } = JSON.parse(textFile); 

      const {
        balances,
        categories,
        transactions,
      } = dataFromBackup;

      if(balances.length === 0 || transactions.length === 0) {
        Alert.alert('There is no data to import');
        return;
      }
  
      clearDatabase();
      importData(realm, balances, categories, transactions, setAppConfig); 
      
      Alert.alert('Data imported with success!');
    } catch (error) {
      if(error instanceof Error && error.message.includes('user canceled the document picker')) return;
      if(error instanceof Error && error.message.includes("Cannot read property 'length' of undefined")) {
        Alert.alert('File not compatible', 'Please use the file generated by the "Export Balances" feature.');
        return;
      };
      Alert.alert('An error has occurred while importing balances.');
      console.log(error);
    } finally {
      setLoading(false);
    }
  }

  const handleRenewButtonPress = () => {
    if(getNextMonthDate() === appConfig.dateToRenewBalance){
      Alert.alert('Balance already renewed today. Try again tomorrow.');
      return;
    }
    Alert.alert('Confirm renewal?', 'This feature will reset the balances of expenses.', [
      {text: 'Yes', onPress: () => createNewBalances()},
      {text: 'No', onPress: () => {}},
    ]);
  }

  const handleExportButtonPress = async () => {
    if(listTransactions.length === 0){
      Alert.alert('There is no data to export');
      return;
    }
    await Share.share({ message: JSON.stringify({
      balances: listBalance,
      categories: listCategory,
      transactions: listTransactions
    })})
  }

  const handleImportButtonPress = () => {
    Alert.alert('Confirm import?', 'This feature will delete all current data, use the imported file data and renew the balances', [
      {text: 'Yes', onPress: () => importBalances()},
      {text: 'No', onPress: () => {}},
    ]);
  }

  return {
    appConfig,
    listCategory,
    listBalance,
    loading, 
    setLoading,
    importBalances,
    getAllCurrentValues,
    handleRenewButtonPress,
    handleExportButtonPress,
    handleImportButtonPress
  }
}

export default useBalance;